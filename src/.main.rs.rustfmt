use eframe::egui;
use std::sync::{Arc, Mutex};
use std::time::Duration;
use std::{println, thread};

const SEC_IN_MINUTE: f64 = 60.;
const MAX_MINUTES: f64 = 120.;

fn main() -> Result<(), eframe::Error> {
    let timer = Timer::new(50.);
    let options = eframe::NativeOptions {
        resizable: false,
        initial_window_size: Some(egui::vec2(320.0, 240.0)),
        ..Default::default()
    };
    eframe::run_native("Rust timer app", options, Box::new(|_cc| Box::new(timer)))
}
struct Timer {
    duration: Arc<Mutex<f64>>,
}

impl Timer {
    fn new(duration: f64) -> Self {
        Timer {
            duration: Arc::new(Mutex::new(duration)),
        }
    }
    fn start(&mut self, ctx:&egui::Context) {
        let duration_clone = Arc::clone(&self.duration);
        let context = ctx.clone();
        thread::spawn(move || {
            while *duration_clone.lock().unwrap() > 0. {
                {
                    *duration_clone.lock().unwrap() -= 1. / 60.;
                    println!("{}", *duration_clone.lock().unwrap())
                }
                context.request_repaint();
                thread::sleep(Duration::new(1, 0));
            }
        });
    }
}

impl eframe::App for Timer {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.heading("Pomodoro");
            ui.add(
                egui::Slider::new(&mut *self.duration.lock().unwrap(), 0.0..=MAX_MINUTES)
                    .text("Duration"),
            );
            ui.vertical_centered_justified(|ui| {
                if ui.button("+").clicked() {
                    *self.duration.lock().unwrap() += 1.;
                }
                if ui.button("-").clicked() {
                    *self.duration.lock().unwrap() -= 1.;
                }
                if ui.button("Start timer").clicked() {
                    self.start(ctx);
                }
            });
        });
    }
}
